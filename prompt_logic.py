# logic_core.py
# Lai's Lab V9.2 - é€»è¾‘å¤§è„‘ (æœ€ç»ˆçº¯å‡€ç‰ˆ)
# è´Ÿè´£ï¼šæƒé™åˆ¤æ–­ã€Promptç»„è£…ã€æ™ºèƒ½æ‹¦æˆªã€é‚®ä»¶è‡ªåŠ¨åŒ–ã€Telegramé€šçŸ¥ã€Airtableå¤‡ä»½

import time
import requests
import smtplib
import random
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime

# å¼•å…¥æ•°æ®åº“
from data_matrix import ROLES_CONFIG, FAQ_DATABASE

# ==========================================
# 1. æ ¸å¿ƒé…ç½®åŒºåŸŸ (Config Zone)
# ==========================================
# âš ï¸ æ³¨æ„ï¼šè¿™é‡Œå…¨éƒ¨ç•™ç©ºï¼
# æ‰€æœ‰çš„å¯†ç å’Œ Key éƒ½ä¼šç”± app.py ä» .streamlit/secrets.toml è¯»å–å¹¶æ³¨å…¥è¿›æ¥ã€‚

CONFIG = {
    # é‚®ä»¶å‘é€é…ç½®
    "EMAIL_SENDER_ADDRESS": "", # ä¼šç”± Secrets æ³¨å…¥
    "EMAIL_APP_PASSWORD": "",   # ä¼šç”± Secrets æ³¨å…¥
    
    # ç®¡ç†å‘˜é…ç½®
    "EMAIL_ADMIN_ADDRESS": "",  # ä¼šç”± Secrets æ³¨å…¥
    "EMAIL_REPLY_TO": "support@laislab.com", # å…¬å¼€é…ç½®
    
    # å¤–éƒ¨æœåŠ¡ API
    "TELEGRAM_BOT_TOKEN": "",   # ä¼šç”± Secrets æ³¨å…¥
    "TELEGRAM_CHAT_ID": "",     # ä¼šç”± Secrets æ³¨å…¥
    "LEMONSQUEEZY_API_KEY": "", # ä¼šç”± Secrets æ³¨å…¥
    
    # Airtable é…ç½®
    "AIRTABLE_API_KEY": "",     # ä¼šç”± Secrets æ³¨å…¥
    "AIRTABLE_BASE_ID": "",    
    "AIRTABLE_TABLE_TICKETS": "Tickets",
    "AIRTABLE_TABLE_USERS": "Users"
}

# ==========================================
# 2. æƒé™ä¸ç”¨é‡é€»è¾‘ (Access & Quota)
# ==========================================

def check_user_tier(email, license_key=None):
    """
    éªŒè¯ç”¨æˆ·èº«ä»½ã€‚
    """
    if not license_key:
        return "Guest"
    
    # æ¨¡æ‹ŸéªŒè¯ (çœŸå®ç‰ˆè¿™é‡Œå¯ä»¥è°ƒç”¨ CONFIG["LEMONSQUEEZY_API_KEY"] å»æŸ¥)
    # ç›®å‰æ¼”ç¤ºé€»è¾‘ï¼šåªè¦ä»¥ LAI- å¼€å¤´æˆ–è€…æ˜¯ç®¡ç†å‘˜ç å°±è¿‡
    if license_key.startswith("LAI-") or license_key == "ADMIN-8888":
        # æ¿€æ´»æˆåŠŸï¼Œè®°å½•åˆ° Airtable
        log_user_to_airtable(email, license_key, "Active")
        return "Pro"
    else:
        return "Invalid"

def check_daily_limit_by_email(email, user_tier, current_usage):
    """
    æ£€æŸ¥æ¯æ—¥ç”¨é‡ (ç»‘å®š Email)
    è¿”å›: (æ˜¯å¦å…è®¸ç”Ÿæˆ, å‰©ä½™æ¬¡æ•°, æœ€å¤§æ¬¡æ•°)
    """
    if user_tier == "Guest":
        max_limit = 5
    else:
        max_limit = 1000 # Pro çš„é˜²æ»¥ç”¨è½¯é™ (FUP)
        
    if current_usage >= max_limit:
        return False, 0, max_limit
    
    remaining = max_limit - current_usage
    return True, remaining, max_limit

def check_mode_lock(user_tier, mode_name):
    """
    æ£€æŸ¥æ¨¡å¼æ˜¯å¦è¢«é”
    é€»è¾‘ï¼šMode 1 (Free) å¯¹æ‰€æœ‰äººå¼€æ”¾ï¼Œå…¶ä»– Mode å¯¹ Guest é”ä½
    """
    if "Free" in mode_name:
        return False # ä¸é”
    
    if user_tier == "Pro":
        return False # Pro ä¸é”
        
    return True # Guest é”ä½

def perform_logout():
    """æ‰§è¡Œç™»å‡ºæ¸…ç†é€»è¾‘"""
    return True

# ==========================================
# 3. æ ¸å¿ƒç”Ÿæˆå¼•æ“ (The Engine)
# ==========================================

def get_guest_loading_messages():
    """Guest ä¸“å±ï¼šæ¸©æŸ”çš„æ’é˜Ÿ/åŠ è½½æç¤ºè¯"""
    messages = [
        "ğŸ”„ Connecting to Shared Server (Guest Queue)...",
        "ğŸ¢ Warming up the AI engine...",
        "â³ Validating request in the public queue...",
        "â˜• Sipping coffee while we generate...",
        "ğŸ’¡ Pro Tip: Enterprise members skip this queue...",
        "âœ¨ Refining the prompt structure..."
    ]
    return messages

def generate_ai_response_mock(role, mode, option_label, user_input, user_tier, language):
    """
    ç”Ÿæˆé€»è¾‘ (åŒ…å«å‡è¿›åº¦æ§åˆ¶)
    """
    # 1. æŸ¥æ‰¾æ¨¡æ¿
    option_list = ROLES_CONFIG[role][mode]
    template = "Act as an expert."
    for opt in option_list:
        if opt["label"] == option_label:
            template = opt["template"]
            break
            
    # 2. ç»„è£… Prompt
    final_prompt = template.replace("{input}", user_input)
    
    # 3. è¿›åº¦æ¡é€»è¾‘ (Guest æ…¢, Pro å¿«)
    delay_time = 0.8 if user_tier == "Pro" else 4.0
    
    # 4. æ¨¡æ‹Ÿç”Ÿæˆç»“æœ
    output = f"""[System: Generated Prompt for {language}]\n\n{final_prompt}\n\n(Instruction: Copy this prompt into ChatGPT/Gemini to get the best result in {language}.)"""
    
    # 5. æ°´å°é€»è¾‘
    if user_tier == "Guest":
        watermark = "\n\n" + "-"*30 + "\nGenerated by Lai's Lab (Free Version)\nğŸ’ Upgrade to Pro for Unlimited Access & No Watermark"
        output += watermark
        
    return output, delay_time

# ==========================================
# 4. æ™ºèƒ½å®¢æœä¸æ‹¦æˆª (Smart Support)
# ==========================================

def smart_intercept(subject):
    """
    FAQ æ‹¦æˆªé€»è¾‘ (è¦†ç›– 16 é¡¹ FAQ)
    """
    subject_lower = subject.lower()
    
    # æ‹¦æˆªè¯åº“æ˜ å°„
    intercept_map = {
        "refund": "Purchase & License",
        "money": "Purchase & License",
        "key": "Purchase & License",
        "lost": "Purchase & License",
        "pdf": "Technical Support",
        "font": "Technical Support",
        "limit": "Usage Limits",
        "quota": "Usage Limits",
        "share": "Privacy & Security",
        "slow": "Technical Support",
        "affiliate": "Business & Affiliate",
        "invoice": "Business & Affiliate",
        "receipt": "Business & Affiliate",
        "commercial": "Usage Limits",
        "offline": "Usage Limits"
    }
    
    for word, category in intercept_map.items():
        if word in subject_lower:
            faq_list = FAQ_DATABASE[category]
            # ç®€å•è¿”å›è¯¥åˆ†ç±»ä¸‹çš„ç¬¬ä¸€æ¡ï¼Œå®é™…å¯ä¼˜åŒ–
            best_match = faq_list[0] 
            return True, f"ğŸ’¡ **Smart Answer:**\n\n**Q: {best_match['q']}**\n**A:** {best_match['a']}"
            
    return False, None

# ==========================================
# 5. è‡ªåŠ¨åŒ–é€šçŸ¥ç³»ç»Ÿ (Automation)
# ==========================================

def log_user_to_airtable(email, key, status):
    """è®°å½•æ–°æ¿€æ´»ç”¨æˆ·åˆ° Airtable"""
    if not CONFIG["AIRTABLE_API_KEY"]: return
    
    url = f"https://api.airtable.com/v0/{CONFIG['AIRTABLE_BASE_ID']}/{CONFIG['AIRTABLE_TABLE_USERS']}"
    headers = {
        "Authorization": f"Bearer {CONFIG['AIRTABLE_API_KEY']}",
        "Content-Type": "application/json"
    }
    data = {
        "fields": {
            "Email": email,
            "License Key": key,
            "Status": status,
            "Date": datetime.now().isoformat()
        }
    }
    try:
        requests.post(url, headers=headers, json=data)
        send_telegram_alert(f"ğŸ’° New Pro User!\nEmail: {email}\nKey: {key}")
    except:
        pass

def log_ticket_to_airtable(ticket_id, email, tier, subject):
    """è®°å½•å·¥å•åˆ° Airtable"""
    if not CONFIG["AIRTABLE_API_KEY"]: return
    
    url = f"https://api.airtable.com/v0/{CONFIG['AIRTABLE_BASE_ID']}/{CONFIG['AIRTABLE_TABLE_TICKETS']}"
    headers = {
        "Authorization": f"Bearer {CONFIG['AIRTABLE_API_KEY']}",
        "Content-Type": "application/json"
    }
    data = {
        "fields": {
            "Ticket ID": str(ticket_id),
            "User Email": email,
            "Tier": tier,
            "Subject": subject,
            "Status": "Pending"
        }
    }
    try:
        requests.post(url, headers=headers, json=data)
    except:
        pass

def send_telegram_alert(message):
    """å‘é€ Telegram é€šçŸ¥"""
    if not CONFIG["TELEGRAM_BOT_TOKEN"]: return
    
    url = f"https://api.telegram.org/bot{CONFIG['TELEGRAM_BOT_TOKEN']}/sendMessage"
    payload = {
        "chat_id": CONFIG["TELEGRAM_CHAT_ID"],
        "text": message
    }
    try:
        requests.post(url, json=payload)
    except:
        pass

def send_auto_reply_email(user_email, user_tier, ticket_id, issue_subject):
    """
    çœŸå®é‚®ä»¶å‘é€ (SMTP)
    """
    sender = CONFIG["EMAIL_SENDER_ADDRESS"]
    password = CONFIG["EMAIL_APP_PASSWORD"]
    admin_email = CONFIG["EMAIL_ADMIN_ADDRESS"]
    reply_to = CONFIG["EMAIL_REPLY_TO"]
    
    if not sender or not password:
        return "Simulation: Email Config Missing"

    # 1. åŒºåˆ† Guest/Pro è¯æœ¯
    if user_tier == "Pro":
        email_subject = f"ğŸ’ [VIP Priority] Ticket #{ticket_id} - We are on it!"
        wait_time = "1 - 2 business days"
        queue_type = "VIP Priority Queue"
        greeting = "Dear Pro Member,"
    else:
        email_subject = f"[Ticket Received] Case #{ticket_id}"
        wait_time = "3 - 5 business days"
        queue_type = "Standard Queue"
        greeting = "Dear User,"

    # 2. é‚®ä»¶æ­£æ–‡
    body = f"""
{greeting}

We have received your support request regarding: "{issue_subject}".

------------------------------------------------
TICKET ID: #{ticket_id}
STATUS: {queue_type}
ESTIMATED REPLY: {wait_time}
------------------------------------------------

While you wait, please check the FAQ section in the sidebar. Many issues (like Lost Keys or PDF Fonts) can be solved instantly there.

If this issue is resolved, no further action is needed.
If you still need help, simply reply to this email.

Best Regards,
Lai's Lab Support Team
    """

    # 3. æ„å»ºé‚®ä»¶
    msg = MIMEMultipart()
    msg['From'] = f"Lai's Lab Support <{sender}>"
    msg['To'] = user_email
    msg['Subject'] = email_subject
    msg.add_header('Reply-To', reply_to)
    
    msg.attach(MIMEText(body, 'plain'))

    # 4. å‘é€è¿‡ç¨‹
    try:
        server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        server.login(sender, password)
        
        # å‘é€ç»™ç”¨æˆ·
        server.send_message(msg)
        
        # é€šçŸ¥ç®¡ç†å‘˜
        send_telegram_alert(f"ğŸ†˜ New Ticket (#{ticket_id})\nUser: {user_email}\nSubject: {issue_subject}")
        
        server.quit()
        return "Email Sent Successfully"
    except Exception as e:
        print(f"SMTP Error: {e}")
        return f"Email Failed: {e}"
